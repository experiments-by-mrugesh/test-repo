name: Test wt (Comprehensive)

on:
  push:
  pull_request:
  workflow_dispatch:

env:
  WT_TEST_ROOT: /tmp/wt-tests
  WT_CONFIG_DIR: /tmp/wt-config

jobs:
  test-wt-comprehensive:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout this repo
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: stable

      - name: Build and install wt
        run: |
          set -e
          git clone https://github.com/raisedadead/wt.git /tmp/wt-src
          cd /tmp/wt-src
          mkdir -p $HOME/bin
          go build -o $HOME/bin/wt ./cmd/wt
          echo "$HOME/bin" >> $GITHUB_PATH

      - name: Setup test environment
        run: |
          set -e
          mkdir -p ${{ env.WT_TEST_ROOT }}
          mkdir -p ${{ env.WT_CONFIG_DIR }}/wt

          # Create global config with hooks for testing
          cat > ${{ env.WT_CONFIG_DIR }}/wt/config.toml << 'EOF'
          worktree_root = "/tmp/wt-tests"
          default_remote = "origin"
          git_timeout = 120
          hook_timeout = 30

          [hooks]
          post_clone = ["touch $WT_PATH/.clone_hook_ran"]
          post_add = ["touch $WT_PATH/.add_hook_ran"]
          EOF

          echo "XDG_CONFIG_HOME=${{ env.WT_CONFIG_DIR }}" >> $GITHUB_ENV
          cat ${{ env.WT_CONFIG_DIR }}/wt/config.toml

      # ============================================================
      # CLONE COMMAND TESTS
      # ============================================================
      - name: "Clone: Basic clone"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}
          wt clone ${{ github.server_url }}/${{ github.repository }} test-clone-basic

          # Verify bare repo structure
          test -d test-clone-basic/.bare || (echo "FAIL: .bare directory not created" && exit 1)
          test -f test-clone-basic/.git || (echo "FAIL: .git file not created" && exit 1)
          test -d test-clone-basic/main || (echo "FAIL: main worktree not created" && exit 1)

          # Verify post_clone hook ran
          test -f test-clone-basic/main/.clone_hook_ran || (echo "FAIL: post_clone hook did not run" && exit 1)

          echo "PASS: Basic clone"

      - name: "Clone: With passthrough args (--depth)"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}
          wt clone ${{ github.server_url }}/${{ github.repository }} test-clone-shallow -- --depth=1

          # Verify shallow clone (should have limited history)
          cd test-clone-shallow/main
          COMMIT_COUNT=$(git rev-list --count HEAD)
          test "$COMMIT_COUNT" -eq 1 || (echo "FAIL: --depth=1 not applied, got $COMMIT_COUNT commits" && exit 1)

          echo "PASS: Clone with passthrough args"

      - name: "Clone: JSON output"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}
          OUTPUT=$(wt clone ${{ github.server_url }}/${{ github.repository }} test-clone-json --json)

          # Verify JSON structure
          echo "$OUTPUT" | jq -e '.success == true' || (echo "FAIL: JSON success not true" && exit 1)
          echo "$OUTPUT" | jq -e '.data.project == "test-clone-json"' || (echo "FAIL: JSON project mismatch" && exit 1)
          echo "$OUTPUT" | jq -e '.data.path' || (echo "FAIL: JSON missing path" && exit 1)
          echo "$OUTPUT" | jq -e '.data.default_branch' || (echo "FAIL: JSON missing default_branch" && exit 1)

          echo "PASS: Clone JSON output"

      - name: "Clone: Force overwrite existing"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}

          # First clone
          wt clone ${{ github.server_url }}/${{ github.repository }} test-clone-force

          # Second clone with --force should succeed
          wt clone ${{ github.server_url }}/${{ github.repository }} test-clone-force --force

          test -d test-clone-force/main || (echo "FAIL: Force clone failed" && exit 1)

          echo "PASS: Clone force overwrite"

      # ============================================================
      # ADD/NEW COMMAND TESTS
      # ============================================================
      - name: "Add: Plain branch"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic
          wt add test-plain-branch

          test -d test-plain-branch || (echo "FAIL: worktree directory not created" && exit 1)
          cd test-plain-branch
          test "$(git branch --show-current)" = "test-plain-branch" || (echo "FAIL: branch name mismatch" && exit 1)

          # Verify post_add hook ran
          test -f .add_hook_ran || (echo "FAIL: post_add hook did not run" && exit 1)

          echo "PASS: Add plain branch"

      - name: "Add: Branch flattening (slashes to dashes)"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic
          wt add feature/auth-system

          # Directory should be flattened
          test -d feature-auth-system || (echo "FAIL: directory not flattened to feature-auth-system" && exit 1)

          # Branch should retain original name
          cd feature-auth-system
          test "$(git branch --show-current)" = "feature/auth-system" || (echo "FAIL: branch name should be feature/auth-system" && exit 1)

          echo "PASS: Add with branch flattening"

      - name: "Add: Using 'new' alias"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic
          wt new test-alias-branch

          test -d test-alias-branch || (echo "FAIL: 'new' alias did not work" && exit 1)

          echo "PASS: Add using 'new' alias"

      - name: "Add: With --base flag"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic
          wt add branch-from-base --base main

          test -d branch-from-base || (echo "FAIL: worktree not created" && exit 1)

          echo "PASS: Add with --base flag"

      - name: "Add: JSON output"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic
          OUTPUT=$(wt add json-test-branch --json)

          echo "$OUTPUT" | jq -e '.success == true' || (echo "FAIL: JSON success not true" && exit 1)
          echo "$OUTPUT" | jq -e '.data.branch == "json-test-branch"' || (echo "FAIL: JSON branch mismatch" && exit 1)
          echo "$OUTPUT" | jq -e '.data.path' || (echo "FAIL: JSON missing path" && exit 1)

          echo "PASS: Add JSON output"

      # ============================================================
      # LIST COMMAND TESTS
      # ============================================================
      - name: "List: Normal output"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic
          OUTPUT=$(wt list)

          # Should show main and the branches we created
          echo "$OUTPUT" | grep -q "main" || (echo "FAIL: main not in list output" && exit 1)
          echo "$OUTPUT" | grep -q "test-plain-branch" || (echo "FAIL: test-plain-branch not in list" && exit 1)

          echo "PASS: List normal output"

      - name: "List: JSON output"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic
          OUTPUT=$(wt list --json)

          echo "$OUTPUT" | jq -e '.success == true' || (echo "FAIL: JSON success not true" && exit 1)
          echo "$OUTPUT" | jq -e '.data.worktrees | length > 0' || (echo "FAIL: JSON worktrees empty" && exit 1)
          echo "$OUTPUT" | jq -e '.data.count > 0' || (echo "FAIL: JSON count should be > 0" && exit 1)

          # Verify structure of worktree entries
          echo "$OUTPUT" | jq -e '.data.worktrees[0].branch' || (echo "FAIL: JSON worktree missing branch" && exit 1)
          echo "$OUTPUT" | jq -e '.data.worktrees[0].path' || (echo "FAIL: JSON worktree missing path" && exit 1)
          echo "$OUTPUT" | jq -e '.data.worktrees[0].status' || (echo "FAIL: JSON worktree missing status" && exit 1)

          echo "PASS: List JSON output"

      - name: "List: Path-only output"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic
          OUTPUT=$(wt list --path)

          # Should output only paths, one per line
          echo "$OUTPUT" | grep -q "/main$" || (echo "FAIL: path output should contain /main" && exit 1)

          # Count lines - should have multiple worktrees
          LINE_COUNT=$(echo "$OUTPUT" | wc -l)
          test "$LINE_COUNT" -gt 1 || (echo "FAIL: should have multiple paths" && exit 1)

          echo "PASS: List path-only output"

      - name: "List: Using 'ls' alias"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic
          OUTPUT=$(wt ls)

          echo "$OUTPUT" | grep -q "main" || (echo "FAIL: 'ls' alias did not work" && exit 1)

          echo "PASS: List using 'ls' alias"

      # ============================================================
      # SWITCH COMMAND TESTS
      # ============================================================
      - name: "Switch: By exact branch name"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic
          OUTPUT=$(wt switch main)

          # Output should be the path to main worktree
          echo "$OUTPUT" | grep -q "main$" || (echo "FAIL: switch output should end with /main" && exit 1)

          echo "PASS: Switch by exact branch name"

      - name: "Switch: By flattened directory name"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic

          # feature/auth-system was created earlier, directory is feature-auth-system
          OUTPUT=$(wt switch feature-auth-system)

          echo "$OUTPUT" | grep -q "feature-auth-system$" || (echo "FAIL: switch by flattened name failed" && exit 1)

          echo "PASS: Switch by flattened directory name"

      - name: "Switch: JSON output"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic
          OUTPUT=$(wt switch main --json)

          echo "$OUTPUT" | jq -e '.success == true' || (echo "FAIL: JSON success not true" && exit 1)
          echo "$OUTPUT" | jq -e '.data.branch == "main"' || (echo "FAIL: JSON branch mismatch" && exit 1)
          echo "$OUTPUT" | jq -e '.data.path' || (echo "FAIL: JSON missing path" && exit 1)

          echo "PASS: Switch JSON output"

      # ============================================================
      # DELETE COMMAND TESTS
      # ============================================================
      - name: "Delete: With -y flag (skip confirmation)"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic

          # Create a branch to delete
          wt add to-delete-y
          test -d to-delete-y || (echo "FAIL: setup failed" && exit 1)

          wt delete to-delete-y -y
          test ! -d to-delete-y || (echo "FAIL: directory should be deleted" && exit 1)

          echo "PASS: Delete with -y flag"

      - name: "Delete: Using 'rm' alias"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic

          wt add to-delete-alias
          wt rm to-delete-alias -y
          test ! -d to-delete-alias || (echo "FAIL: 'rm' alias did not work" && exit 1)

          echo "PASS: Delete using 'rm' alias"

      - name: "Delete: With --force (uncommitted changes)"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic

          wt add to-delete-force

          # Create uncommitted changes
          echo "dirty" > to-delete-force/dirty-file.txt
          cd to-delete-force
          git add dirty-file.txt
          cd ..

          # Should require --force
          wt delete to-delete-force -y --force
          test ! -d to-delete-force || (echo "FAIL: force delete should remove dirty worktree" && exit 1)

          echo "PASS: Delete with --force"

      - name: "Delete: Dry-run"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic

          wt add to-delete-dryrun

          OUTPUT=$(wt delete to-delete-dryrun --dry-run)

          # Directory should still exist
          test -d to-delete-dryrun || (echo "FAIL: dry-run should not delete" && exit 1)
          echo "$OUTPUT" | grep -qi "dry run" || (echo "FAIL: dry-run output missing" && exit 1)

          # Clean up
          wt delete to-delete-dryrun -y

          echo "PASS: Delete dry-run"

      - name: "Delete: JSON output"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic

          wt add to-delete-json
          OUTPUT=$(wt delete to-delete-json -y --json)

          echo "$OUTPUT" | jq -e '.success == true' || (echo "FAIL: JSON success not true" && exit 1)
          echo "$OUTPUT" | jq -e '.data.branch == "to-delete-json"' || (echo "FAIL: JSON branch mismatch" && exit 1)
          echo "$OUTPUT" | jq -e '.data.path' || (echo "FAIL: JSON missing path" && exit 1)

          echo "PASS: Delete JSON output"

      # ============================================================
      # PRUNE COMMAND TESTS
      # ============================================================
      - name: "Prune: Dry-run (no stale worktrees)"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic

          OUTPUT=$(wt prune --dry-run)

          # Since all branches are local-only, they should be considered "stale"
          # (remote branch doesn't exist)
          echo "$OUTPUT"

          echo "PASS: Prune dry-run"

      - name: "Prune: JSON output"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic

          OUTPUT=$(wt prune --dry-run --json)

          echo "$OUTPUT" | jq -e '.success == true' || (echo "FAIL: JSON success not true" && exit 1)
          echo "$OUTPUT" | jq -e '.data.stale_worktrees' || (echo "FAIL: JSON missing stale_worktrees" && exit 1)
          echo "$OUTPUT" | jq -e '.data.dry_run == true' || (echo "FAIL: JSON dry_run should be true" && exit 1)

          echo "PASS: Prune JSON output"

      - name: "Prune: With -y flag"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic

          # Create a worktree for a branch that doesn't exist on remote
          wt add prune-target

          # Prune should find it (branch doesn't exist on remote)
          wt prune -y

          # The branch should be pruned if it was detected as stale
          # Note: This might not delete if the worktree isn't considered stale

          echo "PASS: Prune with -y flag"

      # ============================================================
      # CONFIG COMMAND TESTS
      # ============================================================
      - name: "Config: Init --global"
        run: |
          set -e
          # Use a separate config location for this test
          export XDG_CONFIG_HOME=/tmp/wt-config-init-test
          mkdir -p $XDG_CONFIG_HOME

          wt config init --global --force

          test -f $XDG_CONFIG_HOME/wt/config.toml || (echo "FAIL: global config not created" && exit 1)

          echo "PASS: Config init --global"

      - name: "Config: Init (local/repo)"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic/main

          wt config init --force

          # Should create .wt.toml in project root
          test -f ${{ env.WT_TEST_ROOT }}/test-clone-basic/.wt.toml || (echo "FAIL: local config not created" && exit 1)

          echo "PASS: Config init (local)"

      - name: "Config: Show"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic/main

          OUTPUT=$(wt config show)

          echo "$OUTPUT" | grep -q "worktree_root" || (echo "FAIL: config show missing worktree_root" && exit 1)
          echo "$OUTPUT" | grep -q "default_remote" || (echo "FAIL: config show missing default_remote" && exit 1)

          echo "PASS: Config show"

      - name: "Config: Show JSON"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic/main

          OUTPUT=$(wt config show --json)

          echo "$OUTPUT" | jq -e '.success == true' || (echo "FAIL: JSON success not true" && exit 1)
          echo "$OUTPUT" | jq -e '.data.config' || (echo "FAIL: JSON missing config" && exit 1)
          echo "$OUTPUT" | jq -e '.data.sources' || (echo "FAIL: JSON missing sources" && exit 1)

          echo "PASS: Config show JSON"

      # ============================================================
      # HOOKS COMMAND TESTS
      # ============================================================
      - name: "Hooks: List"
        run: |
          set -e

          # Initialize hooks first
          export XDG_CONFIG_HOME=${{ env.WT_CONFIG_DIR }}
          wt config init --global --force

          OUTPUT=$(wt hooks list)

          # Should list available hooks (may be empty if none installed)
          echo "$OUTPUT"

          echo "PASS: Hooks list"

      - name: "Hooks: List JSON"
        run: |
          set -e
          export XDG_CONFIG_HOME=${{ env.WT_CONFIG_DIR }}

          OUTPUT=$(wt hooks list --json)

          echo "$OUTPUT" | jq -e '.success == true' || (echo "FAIL: JSON success not true" && exit 1)
          echo "$OUTPUT" | jq -e '.data.hooks' || (echo "FAIL: JSON missing hooks array" && exit 1)

          echo "PASS: Hooks list JSON"

      # ============================================================
      # REPAIR COMMAND TESTS
      # ============================================================
      - name: "Repair: Basic repair"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic/main

          OUTPUT=$(wt repair)

          # Should succeed even if nothing to repair
          echo "$OUTPUT" | grep -qi "worktree paths" || (echo "FAIL: repair output unexpected" && exit 1)

          echo "PASS: Repair basic"

      - name: "Repair: JSON output"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic/main

          OUTPUT=$(wt repair --json)

          echo "$OUTPUT" | jq -e '.success == true' || (echo "FAIL: JSON success not true" && exit 1)
          echo "$OUTPUT" | jq -e '.data.project_root' || (echo "FAIL: JSON missing project_root" && exit 1)
          echo "$OUTPUT" | jq -e 'has("data") and (.data | has("repaired"))' || (echo "FAIL: JSON missing repaired field" && exit 1)

          echo "PASS: Repair JSON output"

      # ============================================================
      # COMPLETION COMMAND TESTS
      # ============================================================
      - name: "Completion: Instructions (no args)"
        run: |
          set -e
          OUTPUT=$(wt completion)

          echo "$OUTPUT" | grep -q "Bash" || (echo "FAIL: completion instructions missing Bash" && exit 1)
          echo "$OUTPUT" | grep -q "Zsh" || (echo "FAIL: completion instructions missing Zsh" && exit 1)
          echo "$OUTPUT" | grep -q "Fish" || (echo "FAIL: completion instructions missing Fish" && exit 1)

          echo "PASS: Completion instructions"

      - name: "Completion: Generate bash"
        run: |
          set -e
          OUTPUT=$(wt completion bash)

          # Should output valid bash completion script
          echo "$OUTPUT" | grep -q "bash completion" || echo "$OUTPUT" | grep -q "_wt" || (echo "FAIL: bash completion output invalid" && exit 1)

          echo "PASS: Completion bash"

      - name: "Completion: Generate zsh"
        run: |
          set -e
          OUTPUT=$(wt completion zsh)

          # Should output valid zsh completion script
          echo "$OUTPUT" | grep -q "compdef\|#compdef" || (echo "FAIL: zsh completion output invalid" && exit 1)

          echo "PASS: Completion zsh"

      - name: "Completion: Generate fish"
        run: |
          set -e
          OUTPUT=$(wt completion fish)

          # Should output valid fish completion script
          echo "$OUTPUT" | grep -q "complete" || (echo "FAIL: fish completion output invalid" && exit 1)

          echo "PASS: Completion fish"

      # ============================================================
      # ERROR HANDLING TESTS
      # ============================================================
      - name: "Error: Not in wt project"
        run: |
          set -e
          cd /tmp

          # Commands should fail gracefully when not in a wt project
          if wt list 2>&1; then
            echo "FAIL: list should fail outside wt project"
            exit 1
          fi

          if wt add test-branch 2>&1; then
            echo "FAIL: add should fail outside wt project"
            exit 1
          fi

          echo "PASS: Error handling - not in wt project"

      - name: "Error: Not in wt project (JSON)"
        run: |
          set -e
          cd /tmp

          OUTPUT=$(wt list --json 2>&1 || true)

          echo "$OUTPUT" | jq -e '.success == false' || (echo "FAIL: JSON should indicate failure" && exit 1)
          echo "$OUTPUT" | jq -e '.error' || (echo "FAIL: JSON should have error field" && exit 1)

          echo "PASS: Error handling - not in wt project (JSON)"

      - name: "Error: Invalid branch name"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic

          # Invalid branch names should be rejected
          if wt add ".." 2>&1; then
            echo "FAIL: .. should be rejected"
            exit 1
          fi

          if wt add ".git" 2>&1; then
            echo "FAIL: .git should be rejected"
            exit 1
          fi

          echo "PASS: Error handling - invalid branch names"

      - name: "Error: Worktree not found"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic

          if wt delete nonexistent-branch -y 2>&1; then
            echo "FAIL: delete should fail for nonexistent branch"
            exit 1
          fi

          if wt switch nonexistent-branch 2>&1; then
            echo "FAIL: switch should fail for nonexistent branch"
            exit 1
          fi

          echo "PASS: Error handling - worktree not found"

      # ============================================================
      # GLOBAL --json FLAG TESTS
      # ============================================================
      - name: "Global --json flag works on all commands"
        run: |
          set -e
          cd ${{ env.WT_TEST_ROOT }}/test-clone-basic

          # Test that --json works on various commands
          wt list --json | jq -e '.command == "list"' || (echo "FAIL: list --json missing command field" && exit 1)
          wt switch main --json | jq -e '.command == "switch"' || (echo "FAIL: switch --json missing command field" && exit 1)
          wt config show --json | jq -e '.command == "config show"' || (echo "FAIL: config show --json missing command field" && exit 1)
          wt repair --json | jq -e '.command == "repair"' || (echo "FAIL: repair --json missing command field" && exit 1)

          echo "PASS: Global --json flag works on all commands"

      # ============================================================
      # CLEANUP
      # ============================================================
      - name: Cleanup
        if: always()
        run: |
          rm -rf ${{ env.WT_TEST_ROOT }}
          rm -rf ${{ env.WT_CONFIG_DIR }}
          echo "Cleanup complete"

      - name: Test Summary
        run: |
          echo "========================================"
          echo "       ALL TESTS PASSED"
          echo "========================================"
          echo ""
          echo "Commands tested:"
          echo "  - clone (basic, passthrough, JSON, force)"
          echo "  - add/new (plain, flattening, base, JSON, alias)"
          echo "  - list (normal, JSON, path-only, alias)"
          echo "  - switch (by name, by flattened, JSON)"
          echo "  - delete (y flag, force, dry-run, JSON, alias)"
          echo "  - prune (dry-run, JSON, y flag)"
          echo "  - config (init global, init local, show, JSON)"
          echo "  - hooks (list, JSON)"
          echo "  - repair (basic, JSON)"
          echo "  - completion (instructions, bash, zsh, fish)"
          echo "  - Error handling (not in project, invalid names, not found)"
          echo "  - Global --json flag"
